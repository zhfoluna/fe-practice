web性能优化
    度量标准、编码优化、静态资源优化、交付优化、构建优化、性能监控。
    1、度量标准与设定目标
        1.1、度量标准
            首次有效绘制：内容呈现在页面上
            英雄渲染时间：内容渲染完成
            可交互时间：用户可点击ui并与其交互
            输入响应：界面响应用户输入所需的时间
            感知速度指数：测量页面在加载过程中视觉上的变化速度
            自定义指标：业务需求和用户体验所决定
        1.2、设定目标
            100ms的界面响应时间与60FPS
            速度指标小于1250ms
            3G网络环境下可交互时间小于5s
            重要文件的大小预算小于170kb
    2、编码优化
        编码优化涉及到应用的运行时性能，
        2.1、数据读取速度
            字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢。
            变量从局部作用域到全局作用域的搜索过程越长速度越慢。
            对象嵌套的越深，读取速度就越慢
            对象在原型中存在的位置越深，找到它的速度就越慢
        推荐的做法是缓存对象成员值。将对象成员值缓存到局部变量加快访问速度。
        2.2、DOM
            应用在运行时，性能的瓶颈主要在于DOM操作的代价非常昂贵，
                （1）在JS中对DOM进行访问的代价非常高。请尽可能减少访问DOM的次数
                    （建议缓存DOM属性和元素、把DOM集合的长度缓存到变量中并在迭代中使用。读变量比读DOM的速度要快很多）
                （2）重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，建议先让元素脱离文档流，处理完毕后再让元素回归文档流，这样浏览器只会进行两次重排与重绘
                （3）善于使用时间委托
        2.3  流程控制
            避免使用for...in(它能枚举到原型，所以很慢) 
            在js中倒序循环会略微提升性能
            减少迭代的次数
            基于循环的迭代比基于函数的迭代循环快8倍
            用Map代替大量的if-else和switch会提升性能
    3、静态资源优化
        3.1、使用Brotli或Zopfli进行纯文本压缩
        3.2、图片优化
            尽可能通过srcset, sizes和<picture>元素使用响应式图片。还可以通过<picture>元素使用WebP格式的图片。
            srcset：是一个包含一个或多个源图的源图容器，不同源图用逗号分割，每一个源图由下面两部分组成
                （1）图片url
                （2）x(像素比描述)或w(图片像素宽度描述)描述符（与图片url相隔一个空格），w描述符的加载策略是通过sizes属性里的声明来计算选择的
                    <img
                        srcset=“
                            http://placehold.it/2500 5x,
                            http://placehold.it/1500 3x,
                            http://placehold.it/1000 2x,
                            http://placehold.it/500 1x
                        "
                        src="http://placehold.it/500/abc"
                    />
                    <img
                        srcset=“
                            http://placehold.it/2000 2000w,
                            http://placehold.it/1500 1500w,
                            http://placehold.it/1000 1000w,
                            http://placehold.it/500 500w
                        "
                        sizes=“
                            (max-width: 500px) 500px,
                            (max-width: 1000px) 1000px,
                            (max-width: 1500px) 1500px,
                            2000px
                        "
                        src="http://placehold.it/500/abc"
                    />
            picture：内部的source与img的关系像是相片与相框的关系，相框带有一个底图，有很多不同尺寸的相片，试图找到第一个合适尺寸的相片放到相框里，
                    如果没有找到就不放相片而用相框本身的底图，    
                    <picture>
                        <source media="(max-width: 500px)" srcset="http://placehold.it/500” />
                        <source media="(max-width: 1000px)" srcset="http://placehold.it/1000” />
                        <source media="(max-width: 1500px)" srcset="http://placehold.it/1500” />
                        <img src="http://placehold.it/500/abc” />
                    </picture>
    4、交付优化
        交付优化指的是对页面加载资源以及用户与网页之间的交付过程进行优化。
        4.1、异步无阻塞加载JS
            defer、async、动态创建script标签、使用xhr异步请求js代码并注入到页面
        4.2、使用Intersection Observer实现懒加载
        4.3、优先加载关键的css
            css资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成<head>标签中css的加载与解析之后才会渲染页面。
            如果css文件过大，用户就需要等待很长时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的css提取出来内嵌到
            <head>中，然后再将剩余部分的css用异步的方式加载。
        4.4、资源提示
            定义了html中的link元素与dns-prefetch、preconnect、prefetch、prerender之间的关系。它可以帮助浏览器决定应该连接到哪些源，
            以及应该获取与预处理哪些资源来提升页面性能。
            dns-prefetch：指定一个用于获取资源所需的源（origin），并提示浏览器应该尽可能早的解析。
            preconnect：用于启动预链接，其中包括dns查找、tcp握手、以及可选的tls协议，允许浏览器减少潜在的建立连接的开销。
            prefetch：用于标识下一个导航可能需要的资源。浏览器会获取该资源，一旦将来提取该资源，浏览器可以提供更快的响应。
                    浏览器不会预处理、不会自动执行、不会将其应用于当前上下文。 as与crossorigin选项都是可选的。
            prerender：用于标识下一个导航可能需要的资源。浏览器会获取并执行，       
        4.5、PreLoad：提供了一种声明式的命令，让浏览器提前加载指定资源（加载后并不执行），需要执行时再执行
                好处：将加载和执行分离，不阻塞渲染和document的onload事件
                     提前加载指定资源，不再出现依赖的font字体隔了一段事件才刷出的情况     
        4.6、快速响应的用户界面
            PSI(感知速度指数)是提升用户体验的重要指标，让用户感觉到页面的反馈比没有反馈体验要好的多。
            使用骨架屏或添加一些loading过渡动画提升用户体验             
    5、构建优化
        现在前端应用都需要有构建的过程，项目在构建过程中是否进行了合理的优化，会对web应用的性能有着巨大的影响。
        例如：影响构建后文件的体积、代码执行效率、文件的加载时间、首次有效绘制指标等。
        5.1、使用预编译
        5.2、使用Tree-shaking、Scope hoisting、Code-splitting
            Tree-shaking: 在构建过程中清除无用代码的技术。
            Scope hoisting: 检查import链，尽可能的将散乱的模块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了依次的模块才会被合并。
                            降低代码体积、降低代码在运行时的开销，同时它的运行速度更快。
            Code-splitting：把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。
        5.3、服务端渲染（SSR）
            单页应用需要等js加载完毕后在前端渲染页面，会产生白屏。
            服务端渲染弥补主要内容在前端渲染的成本，减少白屏时间，提神首次有效绘制的速度。          
        5.4、使用import函数动态导入模块
        5.5、使用http缓存头            
    6、其他
        http2
        cdn
一、资源压缩与合并
    html、css、js的压缩和文件的合并。
    html压缩
        1、使用在线网站进行压缩（开发过程中一般不用）
        2、node.js提供了html-minifier工具
        3、后端模版引擎渲染压缩
    css压缩
        1、使用在线网站进行压缩（开发过程中一般不用）
        2、node.js提供了html-minifier工具
        3、使用clean-css对 css压缩
    js压缩
        1、使用在线网站进行压缩（开发过程中一般不用）
        2、node.js提供了html-minifier工具
        3、使用uglifyjs2对js压缩    
二、非核心代码异步加载
    异步加载方式：async和defer、动态创建脚本
三、利用浏览器缓存
    强缓存、协商缓存
四、cdn
    通过将静态资源（js、css、图片）缓存到离用户最近的cdn节点，不但能提升用户访问度，还能节省服务器的贷款消耗，降低负载
    一个地区内只要有一个用户先加载资源，在cdn中建立了缓存，该读取的其他后续用户都能因此受益。
五、预解析dns
    资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用。
    <link rel="dns-prefetch" href="//example.com">








